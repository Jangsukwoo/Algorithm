package 순열조합;
import java.util.Arrays;

/*
 * 비트는 0과 1 두가지의 상태를 가지고
 * 8비트(1byte)크기의 자료형은
 * 비트가 8개니까 8가지의 상태를 저장할 수 있다.
 * 
 * int는 4byte니까 32개의 상태를 저장할 수 있게된다.
 * 
 * * 시프트연산의 유용성
 * 
 * 각 자리는 2의 승수라서
 * 확인할 때마다 2,4,8,16처럼 특정 비트를 표현하기는 좀 번거롭다
 * 허나 시프트연산을 사용하면 수월하게 원하는 자리에 대한 비트값을 확인할 수 있다.
 * 
 *  
 *  * 시프트연산 (비트 마스크)
 * 1<<3은 뒤에 0이 3개라고 생각하면 쉽다.(Left Shift)
 * 즉, 비트로 1000
 * 
 * ** 확인은 and , 세팅은 or
 *  
 *  * 특정 자리 비트값 확인하기 
 * 원하는 자리의 비트값 확인하기는 And인 & 연산자로 하면된다.
 * 숫자 5가 있다고 하자
 * 비트로 0101인데
 * 3번째의 비트값을 알고싶다. (4자리 비트의 3번쨰,2번쨰,1번쨰,0번쨰)
 * int num = 5면
 * num & (1<<3)으로 하면
 * 3번째 자리의 비트값이 확인된다.
 * 
 *  * 특정 비트값 1로 만들기 (켜기)
 * 만약 3번쨰 자리의 비트값을 1로 세팅하고싶다면 or인 | 연산자를 사용.
 * num | (1<<3)  <- 3번째 비트 값을 1로 업데이트
 * 
 *  * 특정 비트값 토글 시키기(켜져있는건 끄고, 꺼져있는건 키는) XOR
 *  num ^ (1<<3) 
 */
public class 비트마스킹 {
	static boolean[] visit;
	public static void main(String[] args) {
		 //visit = new boolean[3];
		 for(int i = 1; i <= 3; i++) {// i는 비트를 몇개 쓸것인가
			 visit = new boolean[i];
			 for(int j = 0, size = 1 << i; j < size; j++) { //j는 2^i - 1 까지 본다.
				 //1로 다 채워진 비트를 만드려는 반복문임
				 //j<size 니까 1로 채워진 애만 보겠지 
				 //숫자 j는 0~7이고 이를 각각 비트로 표현하면 000부터 111이니까 
				 //숫자 자체가 모든 경우의수를 표현한다. 
				 for(int k = 0; k < i; k++) {//자리를 검사 
					 if(((1 << k) & j) == 0) {
						 visit[k] = false;
					 } else {
						visit[k] = true;
					 }
				 }
				 System.out.println(Arrays.toString(visit));
			 }
		 }
	}
}
