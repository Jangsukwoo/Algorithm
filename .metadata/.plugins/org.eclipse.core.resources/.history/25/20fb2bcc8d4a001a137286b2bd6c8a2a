package CodingStudySamsungProblem;

import java.util.Arrays;
import java.util.Scanner;

/*
 * 주사위 윷놀이판이 있고
 * 처음에 시작칸에 말 4개가 있음
 * 말은 게임판에 적힌 화살표 방향으로 움직임
 * 칸의 색에 따라 움직이는 방향이 정해져있고
 * 시작과 도착칸은 말이 이미 있어도 이동할 수 있지만
 * 다른 이동하려고하는 칸에 이미 말이 있는 경우
 * 그 칸으로 이동할 수 없다.
 * 도착칸을 넘어가면
 * 그 칸에서 멈춤 
 * 
 * 말이 이동할 때마다 그 칸에 있는 점수가 추가된다. 
 * 최종적으로 얻는 스코어는?
 * 
 * 맵을 어떻게 만들지
 * 
5 1 1 1 1 4 5 1 1 2 //가운데 겹치게
 */
public class 주사위윷놀이 {
	static int[] dice = new int[10];
	static int[] redline = new int[] {0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40};
	static int[][] blueline = new int[][]{{10,13,16,19,25},{20,22,24,25},{30,28,27,26,25}};
	static int[] centerRedline = new int[] {25,30,35,40};//마지막 40도 처리해줘야할듯
	static boolean[] rVisit,crVisit;
	static boolean[][] bluelineVisit;

	static int[] pickHorse = new int[10];
	static boolean[] arriveHorse;

	static Horse[] horselist = new Horse[4];
	
	static int score;
	static int maxScore;
	
	static int cnt=0;

	static class Horse{
		String line;
		int bluelineNumber;
		int bluelineIdx;
		int redlineIdx;
		int centerlineIdx;
		public Horse(String line,int redlineIdx) {
			this.line = line;
			this.redlineIdx = redlineIdx;
		}

	}
	public static void main(String[] args) {
		setData();
		dfs(0);
		//play();
		System.out.println(maxScore);
	}

	private static void play(){		
		for(int i=0;i<4;i++) horselist[i] = new Horse("red",0);//모두 레드에서 시작
		rVisit = new boolean[redline.length];
		crVisit = new boolean[centerRedline.length];
		arriveHorse = new boolean[4];
		bluelineVisit[0] = new boolean[blueline[0].length];
		bluelineVisit[1] = new boolean[blueline[1].length];
		bluelineVisit[2] = new boolean[blueline[2].length];
		score=0;
		int[] testcase = new int[] {0,0,1,0,2,2,2,0,0,2};//말 한마리만 이동해보자
		for(int i=0,move;i<10;i++){//주사위 하나씩
			move = dice[i];
			//moveHorse(move,testcase[i]);//이동
			//horseIdx=(horseIdx+1)%4;
			if(arriveHorse[pickHorse[i]]==false) {
				moveHorse(move,pickHorse[i]);//이동 가능하면 보낸다.	
			}
		}
		maxScore = Math.max(maxScore,score);
	}

	private static void dfs(int depth) {
		if(depth==10){//10개 고름
			play();
			return;
		}
		for(int i=0;i<4;i++){
			pickHorse[depth]=i;
			dfs(depth+1);
		}
	}

	private static void moveHorse (int move,int horseIdx) {
		//		System.out.println((horseIdx+1)+"번말");
		//		System.out.println("이동전");
		//		System.out.println("이동값 "+move);
		//		System.out.println(horselist[horseIdx].line+"위에있음");
		//		System.out.println();
		switch (horselist[horseIdx].line) {
		case "red":
			redlineCheck(move,horseIdx);
			break;
		case "blue":
			bluelineCheck(move,horseIdx);
			break;
		case "center"://마지막 센터라인이면 
			ceterlineCheck(move,horseIdx);
			break;
		}
		//		System.out.println("이동후");
		//		System.out.println("얻은 스코어"+currnetScore);
		//		System.out.println(horselist[horseIdx].line+"위에있음");
		return ;
	}
	private static void redlineCheck(int move, int horseIdx) {
		int currentRedIdx = horselist[horseIdx].redlineIdx;
		int nextRedIdx = currentRedIdx+move;
		if(rVisit.length>nextRedIdx){//영역 안에 있고 
			if(rVisit[nextRedIdx]==false){//false면
				rVisit[nextRedIdx] = true;
				rVisit[currentRedIdx] = false;//떠남
				if(nextRedIdx==(rVisit.length-1)){//마지막 값이면
					crVisit[crVisit.length-1]=true;
				}
				score+=redline[nextRedIdx];//스코어 획득
				if(redline[nextRedIdx]==10){
					horselist[horseIdx].line="blue";
					horselist[horseIdx].bluelineNumber=10;
					horselist[horseIdx].bluelineIdx=0;
				}else if(redline[nextRedIdx]==20){
					horselist[horseIdx].line="blue";
					horselist[horseIdx].bluelineNumber=20;
					horselist[horseIdx].bluelineIdx=0;
				}else if(redline[nextRedIdx]==30) {
					horselist[horseIdx].line="blue";
					horselist[horseIdx].bluelineNumber=30;
					horselist[horseIdx].bluelineIdx=0;
				}else {//
					horselist[horseIdx].redlineIdx = nextRedIdx;
				}
			}
		}else {//영역 넘어가버리면
			arriveHorse[horseIdx]=true;//도착!
			rVisit[currentRedIdx] = false;//얜 떠나고 끝남
			if(currentRedIdx==(rVisit.length-1)){//마지막 값이면
				crVisit[crVisit.length-1]=false;
			}
		}
	}

	private static void bluelineCheck(int move, int horseIdx) {
		int curentBlueIdx = horselist[horseIdx].bluelineIdx;
		int nextBlueIdx =0;
		int bluelineIdx=0;
		boolean ok = false;
		if(horselist[horseIdx].bluelineNumber==10) bluelineIdx=0;
		else if(horselist[horseIdx].bluelineNumber==20) bluelineIdx=1;
		else if(horselist[horseIdx].bluelineNumber==30) bluelineIdx=2;
		nextBlueIdx=curentBlueIdx+move;
		if(bluelineVisit[bluelineIdx].length>nextBlueIdx){//아직 라인 안이고
			if(bluelineVisit[bluelineIdx][nextBlueIdx]==false){//가려는곳이 false면 
				if(nextBlueIdx==(bluelineVisit[bluelineIdx].length-1)){//만약 가려는곳이 센터전환점이면
					if(crVisit[0]==false){//아무도 방문 안되어있으면 
						ok=true;
						crVisit[0]=true;
						score+=blueline[bluelineIdx][nextBlueIdx];//스코어 획득
						horselist[horseIdx].centerlineIdx = 0;
						horselist[horseIdx].line="center";//센터라인에 올림
						bluelineVisit[bluelineIdx][curentBlueIdx]= false;//떠남
					}
				}else{//센터 전환점이 아니면
					ok=true;
					horselist[horseIdx].bluelineIdx = nextBlueIdx;
					horselist[horseIdx].line="blue";	
					score+=blueline[bluelineIdx][nextBlueIdx];//스코어 획득
					bluelineVisit[bluelineIdx][curentBlueIdx] = false;//떠남
					bluelineVisit[bluelineIdx][nextBlueIdx]=true;
				}
			}//가려는곳이 false가 아니면 안간다.
		}else {//라인밖이면 센터라인에 갈 수 있는지?
			int centerIdx = curentBlueIdx+move-(bluelineVisit[bluelineIdx].length-1);
			if(centerIdx<crVisit.length){//센터 영역 안에 들어갈 수 있으며
				if(crVisit[centerIdx]==false){//그 자리에 갈 수 있으면
					ok=true;
					bluelineVisit[bluelineIdx][curentBlueIdx] = false;//떠남
					crVisit[centerIdx] = true;
					score+=centerRedline[centerIdx];//스코어 획득
					horselist[horseIdx].centerlineIdx=centerIdx;
					horselist[horseIdx].line="center"; //센터에 올림
				}
			}else {//센터 영역 넘어가버리면
				ok=true;
				bluelineVisit[bluelineIdx][curentBlueIdx] = false;//떠남
				arriveHorse[horseIdx]=true;//도착!
			}
		}
		
		//떠난 경우에 레드에서 떠났으면 red값 처리
		if(ok) {
			if(blueline[bluelineIdx][curentBlueIdx]==10){//시작 위치인경우는 red에서도 떠남처리필요
				rVisit[5]=false;//떠남처리
			}else if(blueline[bluelineIdx][curentBlueIdx]==20) {
				rVisit[10]=false;//떠남처리
			}else if(blueline[bluelineIdx][curentBlueIdx]==30) {
				rVisit[15]=false;//떠남처리
			}
		}
	}
	private static void ceterlineCheck(int move, int horseIdx) {
		int currentCenterIdx = horselist[horseIdx].centerlineIdx;
		int nextCenterIdx = currentCenterIdx+move;
		if(crVisit.length>nextCenterIdx){//영역 안에 있으며 
			if(crVisit[nextCenterIdx]==false){//갈 수 있는데
				if(nextCenterIdx==(crVisit.length-1)){//마지막지점에 가려한다면
					if(rVisit[rVisit.length-1]==false){//마지막에 아무도 없을 때만
						score+= centerRedline[nextCenterIdx];
						crVisit[currentCenterIdx] = false;
						crVisit[nextCenterIdx] = true;
						rVisit[rVisit.length-1] = true;
						horselist[horseIdx].centerlineIdx=nextCenterIdx;
					}
				}else {
					score+= centerRedline[nextCenterIdx];
					crVisit[currentCenterIdx] = false;
					crVisit[nextCenterIdx] = true;
					horselist[horseIdx].centerlineIdx=nextCenterIdx;
				}
			}
		}else {//영역 넘어가버리면
			crVisit[currentCenterIdx] = false;//얜 떠나고 끝남
			arriveHorse[horseIdx]=true;//도착!
			if(currentCenterIdx==(crVisit.length-1)){//마지막 값이면
				rVisit[rVisit.length-1]=false;
			}
		}
	}

	private static void setData() {
		Scanner sc = new Scanner(System.in);
		for(int i=0;i<10;i++) dice[i] = sc.nextInt();//주사위
	}
}
