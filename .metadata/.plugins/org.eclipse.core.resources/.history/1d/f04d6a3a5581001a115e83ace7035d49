package CodingStudyHW;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/*
 * 17:30
 * 고객의 설문지에
 * 접수 창구 번호와
 * 정비 창구 번호가 존재
 * 
 * 차량 정비소에는 N개의 접수창구, M개의 정비 창구가 있음
 * 
 * 첫단계 : 접수 창구에서 고장 접수
 * 두번째 단계 : 정비 창구에서 차량 정비
 * 
 * 접수 창구와 정비 창구 각각은 담당자 별 처리 시간이 다름
 * 
 * 접수 창구 i의 고장 접수,처리 시간 ai
 * 정비 창구 j의 정비 처리 시간 bj
 * 
 * 방문 고객 수 K
 * 
 * 도착하는대로 1번부터 고객 번호 부여 받음
 * 고객 번호 k의 고객이 차량 정비소에 도착하는 시간 tk
 * 정비소에 도착하면
 * 빈 접수 창구가 있는 경우
 * 빈 접수 창구로 가서 고장 접수
 * 접수 창구가 없으면 빈 접수 창구가 생길 때 까지 기다림
 * 
 * 접수 창구 우선순위
 * ->여러 고객이 기다리고있으면
 * 고객 번호가 낮은 순서대로 우선 접수
 * 여러개의 빈 접수 창구-> 가장 번호 작은 창구
 * 
 * 정비 창구 우선순위
 * 먼저 기다린 고객
 * 두 명 이상의 고객이 접수 창구에서 동시 접수 후 정비로 이동
 * 이용했던 접수 창구가 작은 고객이 우선처리
 * 빈 창구가 여러개면 정비 창구가 작은 곳으로 이동.
 * 
 * 시키는대로 구현해야할것같다.
 * 
 * 접수 먼저 구현하고
 * 정비 구현하자 차근차근.
 * 
 */
public class 차량정비소 {
	static int T;
	static int N,M,K,A,B;
	static int[] reception; //접수처
	static int[] garage; //정비소

	static int[] receptionTime;
	static int[] garageTime;

	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	static Customer[] customers;
	static PriorityQueue<Customer> receptionWating;
	static class Customer implements Comparable<Customer>{
		int arriveTime;
		int customerNumber;
		int idx;
		public Customer() {
			
		}
		
		public Customer(int arriveTime) {
			this.arriveTime = arriveTime;
		}
		public void setCustomerNumber(int number) {//고객 번호 부여
			this.arriveTime = number;
		}

		@Override
		public int compareTo(Customer o) {
			return Integer.compare(this.arriveTime, o.arriveTime);
		}//도착시간 기준
	}
	public static void main(String[] args) throws NumberFormatException, IOException {
		T = Integer.parseInt(br.readLine());
		for(int testcase=1;testcase<=T;testcase++) {
			setData();
			garageSimulation();
		}
	}
	private static void garageSimulation() {
		int time=0;
		int customerID = 1;
		while(true){
			/*
			 * 	접수 창구의 우선순위는 아래와 같다.
   				① 여러 고객이 기다리고 있는 경우 고객번호가 낮은 순서대로 우선 접수한다.
   				② 빈 창구가 여러 곳인 경우 접수 창구번호가 작은 곳으로 간다.
			 */
			for(int i=1;i<=N;i++){//접수처 확인
				if(receptionTime[i]==0){ //접수처에서 놀고 있는 상담원
					if(time>=receptionWating.peek().arriveTime){//도착했거나 미리 도착해있는 고객이 있으면 
						receptionTime[i] = reception[i];//처리 시간 부여
						
					}
				}
			}

		}
	}
	private static void setData() throws IOException {
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		K = Integer.parseInt(st.nextToken());
		A = Integer.parseInt(st.nextToken());
		B = Integer.parseInt(st.nextToken());
		reception = new int[N+1];
		garage = new int[M+1];
		customers = new Customer[K];
		receptionWating = new PriorityQueue<Customer>();
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<N;i++) reception[i] = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<M;i++) garage[i] = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<K;i++) {
			customers[i] = new 
			receptionWating.add(new Customer(Integer.parseInt(st.nextToken())));
		}
	}
}
