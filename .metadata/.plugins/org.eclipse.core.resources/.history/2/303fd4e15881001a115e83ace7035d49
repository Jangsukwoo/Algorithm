package CodingStudyHW;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/*
 * 17:30
 * 고객의 설문지에
 * 접수 창구 번호와
 * 정비 창구 번호가 존재
 * 
 * 차량 정비소에는 N개의 접수창구, M개의 정비 창구가 있음
 * 
 * 첫단계 : 접수 창구에서 고장 접수
 * 두번째 단계 : 정비 창구에서 차량 정비
 * 
 * 접수 창구와 정비 창구 각각은 담당자 별 처리 시간이 다름
 * 
 * 접수 창구 i의 고장 접수,처리 시간 ai
 * 정비 창구 j의 정비 처리 시간 bj
 * 
 * 방문 고객 수 K
 * 
 * 도착하는대로 1번부터 고객 번호 부여 받음
 * 고객 번호 k의 고객이 차량 정비소에 도착하는 시간 tk
 * 정비소에 도착하면
 * 빈 접수 창구가 있는 경우
 * 빈 접수 창구로 가서 고장 접수
 * 접수 창구가 없으면 빈 접수 창구가 생길 때 까지 기다림
 * 
 * 접수 창구 우선순위
 * ->여러 고객이 기다리고있으면
 * 고객 번호가 낮은 순서대로 우선 접수
 * 여러개의 빈 접수 창구-> 가장 번호 작은 창구
 * 
 * 정비 창구 우선순위
 * 먼저 기다린 고객
 * 두 명 이상의 고객이 접수 창구에서 동시 접수 후 정비로 이동
 * 이용했던 접수 창구가 작은 고객이 우선처리
 * 빈 창구가 여러개면 정비 창구가 작은 곳으로 이동.
 * 
 * 시키는대로 구현해야할것같다.
 * 
 * 접수 먼저 구현하고
 * 정비 구현하자 차근차근.
 * 
1
2 2 6 1 2
3 2
4 2
0 0 1 2 3 4
 * 
 */
public class 차량정비소 {
	static int T;
	static int N,M,K,A,B;
	static int[] reception; //접수처
	static int[] garage; //정비소

	static int[][] receptionTime;
	static int[][] garageTime;

	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	static Customer[] customers;
	static PriorityQueue<Customer> receptionWating;
	static PriorityQueue<Customer> garageWating;
	static class Customer{
		int arriveTime;
		int customerNumber;
		int receptionHistory;
		int idx;
		public Customer(int arriveTime,int idx) {
			this.arriveTime = arriveTime;
			this.idx = idx;
		}
		public void setCustomerNumber(int number) {//고객 번호 부여
			this.arriveTime = number;
		}
		public void setReciptionHistory(int number) {
			this.receptionHistory = number;
		}
	}
	public static void main(String[] args) throws NumberFormatException, IOException {
		T = Integer.parseInt(br.readLine());
		for(int testcase=1;testcase<=T;testcase++) {
			setData();
			garageSimulation();
		}
	}
	private static void garageSimulation() {
		int time=0;
		int customerID = 1;
		while(time<=50){
			/*
			 * 	접수 창구의 우선순위는 아래와 같다.
   				① 여러 고객이 기다리고 있는 경우 고객번호가 낮은 순서대로 우선 접수한다.
   				② 빈 창구가 여러 곳인 경우 접수 창구번호가 작은 곳으로 간다.
			 */
			checkReception();
			for(int i=1;i<=N;i++){//접수처 확인
				if(receptionTime[i][0]==0){ //접수처에서 놀고 있는 상담원
					if(receptionWating.peek()!=null && time>=receptionWating.peek().arriveTime){//도착했거나 미리 도착해있는 고객이 있으면 
						int currentCustomerIdx = receptionWating.poll().idx;
						receptionTime[i][0] = reception[i];//처리 시간 부여
						receptionTime[i][1] = currentCustomerIdx; //담당 고객
						customers[currentCustomerIdx].setCustomerNumber(customerID);//고객 번호 부여 
						customers[currentCustomerIdx].setReciptionHistory(i);
						System.out.println("시간"+time+" "+"접수처 "+i +" "+"고객번호"+customerID);
						customerID++;
					}
				}
			}
			workReception();//접수처 일처리하기
			
			/*
			 * 	정비 창구의 우선순위는 아래와 같다.
   				① 먼저 기다리는 고객이 우선한다.
   				② 두 명 이상의 고객들이 접수 창구에서 동시에 접수를 완료하고 정비 창구로 이동한 경우,이용했던 접수 창구번호가 작은 고객이 우선한다.
   				③ 빈 창구가 여러 곳인 경우 정비 창구번호가 작은 곳으로 간다.
			 */
			
			time++;//시간 증가 
		}
	}
	private static void workReception() {
		for(int i=1;i<=N;i++){//접수처 확인
			if(receptionTime[i][0]>0){ //일중이면 일한거로 1초 까줌  
				receptionTime[i][0]--;
			}
		}
	}
	private static void setData() throws IOException {
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		K = Integer.parseInt(st.nextToken());
		A = Integer.parseInt(st.nextToken());
		B = Integer.parseInt(st.nextToken());
		reception = new int[N+1];
		receptionTime = new int[N+1][2];
		garage = new int[M+1];
		customers = new Customer[K];
		receptionWating = new PriorityQueue<Customer>(new Comparator<Customer>() {
			@Override
			public int compare(Customer o1, Customer o2) {
				return Integer.compare(o1.arriveTime,o2.arriveTime);
			}
		});//기다린 시간 기준으로.
		
		garageWating = new PriorityQueue<Customer>(new Comparator<Customer>(){
			@Override
			public int compare(Customer o1, Customer o2) {
				return Integer.compare(o1.receptionHistory,o2.receptionHistory);//접수 창구 기준
			}
		});//접수 창구 기준으로.
		
		st = new StringTokenizer(br.readLine());
		for(int i=1;i<=N;i++) reception[i] = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(br.readLine());
		for(int i=1;i<=M;i++) garage[i] = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<K;i++) {
			customers[i] = new Customer(Integer.parseInt(st.nextToken()),i);
			receptionWating.add(customers[i]);
		}
	}
}
