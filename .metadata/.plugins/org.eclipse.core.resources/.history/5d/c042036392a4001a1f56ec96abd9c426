package CodingAcademy;

import java.util.Arrays;

/*
 * Heap Sort(nlogn)
 */
public class 변리사_3번 {
	public static void main(String[] args) {
		int[] data = new int[] {0,9,8,7,6,5,4,3,2,1};
		int[] data2 = new int[] {0,9,2,3,4,5,6,7,8,1};
		int[] data3 = new int[] {0,9,8,2,8,3,7,4,6,5};
		int[] data4 = new int[] {0,9,6,5,8,3,5,2,1,6};
		int size = data.length;
		AAASort(data,size);
	}

	private static void AAASort(int[] a, int size){
		System.out.println("받은 배열");
		System.out.println(Arrays.toString(a));
		int n = size-1;
		int temp=0;
		//root = (i-1)/2
		for(int i = n/2; i>=2 ;i--) {// heap 구성
			BBB(a,i,n);
			System.out.println(Arrays.toString(a));
		} //1/2개만 봐도 된다.
		System.out.println("힙정렬시작");
		System.out.println(Arrays.toString(a));
		for(int i=n;i>=2;i--) {
			System.out.println("힙구조만들기전");
			System.out.println(Arrays.toString(a));
			System.out.println("i-1의값"+a[i-1]);
			BBB(a,1,i-1);
			System.out.println("힙구조 만들고");
			System.out.println(Arrays.toString(a));
			temp = a[1]; //1은 root고 힙구조를 만들었으므로 가장 꼭대기는 항상 최대값이 유지된다.
			/*
			 * To write pseudo code
			 */
			a[1] = a[i];
			a[i] = temp;
			System.out.println("스왑");
			System.out.println(Arrays.toString(a));
		}
		
		System.out.println("최종 정렬상태");
		System.out.println(Arrays.toString(a));
		
	}

	private static void BBB(int[] a, int h, int m) {
		//h는 확인하고자 하는 노드 번호
		//
		System.out.println("들어온 h값"+h+" "+a[h]);
		int imsi = a[h];//부모의 값
		int j = 0;
		for(j=2*h;j<=m;j=j*2){ //자식 확인 
			if(j<m) {
				if(a[j]<a[j+1]) {//왼쪽 자식과 오른쪽 자식 중 더 큰 자식
					j+=1;
				}
			}//
			if(imsi>=a[j]) break;//부모보다 작거나 같으면 끝 
			else {//부모보다 크면 Swap
				/*
				 * To write pseudo code
				 */
				a[h]=a[j];
				h=j;
			}
		}
		a[j/2]=imsi;
	}
}
