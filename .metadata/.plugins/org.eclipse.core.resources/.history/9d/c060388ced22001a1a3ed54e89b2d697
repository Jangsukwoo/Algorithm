package winterSDS;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 * 쿼드 트리 
 * N by N
 * 4<=N<=64
 * N은 2의 지수승
 * 
 * 최적 분할 쿼드-트리
 * 쿼드-트리 분할 : 주어진 정방행렬을 동일한 크기의 정방 행렬 4개로 
 * 최소 정방행렬(2x2)이 될때 까지 나누는 것
 * 
 * 정방행렬 대상이 될 때 1표시 
 * 사분면 : quadrant
 */
public class QuadTree {
	static int N;
	static int[][] Matrix;
	static StringBuilder sb;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for(int testcase=1;testcase<=T;testcase++) {
			sb = new StringBuilder();
			String readLine = br.readLine();
			StringTokenizer st = new StringTokenizer(readLine);
			N = Integer.parseInt(st.nextToken());
			Matrix = new int[N][N];
			for(int row=0;row<N;row++) {
				for(int col=0;col<N;col++) {
					Matrix[row][col] = Integer.parseInt(st.nextToken());
				}
			}
			//처리
			dfs(0,0,N);
		}
	}
	private static void dfs(int leftTopRow, int leftTopCol,int size) {
		if(size==2){//2 by 2 행렬이면 더이상 정방행렬로 나눌 수 없으므로 여기서 종료  
			return ;
		}
		int binaryValue = isDivide(leftTopRow,leftTopCol,size);//분할이 되는가?
		
	
	}
	private static int isDivide(int leftTopRow, int leftTopCol, int size) {
		int maxA = getMatrixMaxValue(leftTopRow,leftTopCol,leftTopRow+size,leftTopCol+size);//정방행렬 A의 최대값
		int minB=0;
		//제 1,2,3,4 분면 각각의 최대값
		int maxB0 = getMatrixMaxValue(leftTopRow, leftTopCol, (leftTopRow+(size/2)), (leftTopCol+(size/2)));
		int maxB1 = getMatrixMaxValue(leftTopRow, (leftTopCol+(size/2)),(leftTopRow+(size/2)),(leftTopCol+size));
		int maxB2 = getMatrixMaxValue((leftTopRow+(size/2)),leftTopCol,(leftTopRow+size),(leftTopCol+(size/2)));
		int maxB3 = getMatrixMaxValue((leftTopRow+(size/2)),(leftTopCol+(size/2)),(leftTopRow+size),(leftTopCol+size)); 
		return 0;
	}
	private static int getMatrixMaxValue(int leftTopRow,int leftTopCol, int rightBottomRow, int rightBottomCol) {
		int max=0;
		for(int row=leftTopRow;row<rightBottomRow;row++) {
			for(int col=leftTopCol;col<rightBottomCol;col++){
				if(max>Matrix[row][col]) max = Matrix[row][col];
			}
		}
		return max;
	}
}
