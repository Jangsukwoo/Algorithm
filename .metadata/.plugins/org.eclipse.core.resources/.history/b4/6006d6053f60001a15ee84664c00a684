package CodingStudyHW;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/* 15:10~
 * 컴퓨터 대수 N (1<=N<=1000)
 * 
 * 컴퓨터는 직접 연결되어있거나 거쳐서 연결되어있는 경우가 있는데
 * 컴퓨터와 컴퓨터를 연결하는 회선의 성능은 각각 차이가 있다.
 * 
 * 복구할 회선의 개수 K
 */
public class 네트워크복구 {
	static int N,M;//컴퓨터수, 연결정보수 
	static ArrayList<int[]>[] adjList;
	static int INF = 987654321;
	static int[] dist;
	public static void main(String[] args) throws IOException {
		setData();
		dijkstra();
	}
	private static void dijkstra() {
		PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
		pq.add(1);
		dist[1] = 0;
		while(!pq.isEmpty()){
			int currentVertax = pq.poll();
			for(int i=0;i<adjList[currentVertax].size();i++){
				
			}
		}
	}
	private static void setData() throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		adjList = new ArrayList[N+1];
		dist = new int[N+1];
		for(int i=1;i<=N;i++) adjList[i] = new ArrayList<int[]>();
		for(int i=1;i<=N;i++) dist[i] = INF;
		for(int i=0,from,to,cost;i<M;i++) {
			st = new StringTokenizer(br.readLine());
			from = Integer.parseInt(st.nextToken());
			to = Integer.parseInt(st.nextToken());
			cost = Integer.parseInt(st.nextToken());
			adjList[from].add(new int[] {to,cost});
			adjList[to].add(new int[] {from,cost});
		}
		
	}
}
