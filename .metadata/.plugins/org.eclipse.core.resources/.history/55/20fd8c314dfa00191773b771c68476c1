package Simulation;

import java.util.Scanner;
import java.util.Stack;

/*
 * 4:50~5:30
 * 6:00~
 * 
 * 정수를 담는 1개의 배열
 * 이 배열의 칸 하나를 가리키는 포인터
 * 명령구성
 * - : 포인터가 가리키는 숫자 1 감소
 * + : 포인터가 가리키는 숫자 1 증가
 * < : 포인터 왼쪽 이동
 * > : 포인터 오른쪽 이동
 * [ : 포인터가 가리키는 숫자가 0이면 [와 짝을 이루는 ]로 점프
 * ] : 포인터가 가리키는 숫자가 0이 아니면 ]와 짝을 이루는 [로 점프
 * . : 포인터가 기리키는 숫자 출력
 * , : 문자 하나를 읽고 포인터가 가리키는 곳에 저장. 입력의 마지막(EOF)인 경우 255 저장
 * 단, 값 저장시 2^8 (256) 모듈러 연산으로 256을 넘지않도록 삽입
 * 
 * 첫번째 명령부터 순차적으로 수행하고
 * 수행할 명령이 없으면 프로그램이 종료된다.
 * 데이터 배열의 값은 0으로 초기화되어있고 포인터가 가리키는 칸은 0이다.
 * 
 * [의 개수 - ]의 개수가 0이거나 큰 값으로 종료되면 잘 짜여진 프로그램이다.
 * 이 문제는 이 프로그램이 무한루프에 빠지는지 안빠지는지 판단하는 코드를 짜면된다.
 * 
 * ~
 */
class Bracket{
	int left;
	int right;
	public Bracket(int l,int r){
		left=l;
		right =r;
	}
}
public class BrainFuckInterpreter {
	static int memorySize;
	static int codeSize;
	static int inputSize;
	static int memoryPointer,inputPointer,codePointer;
	static int cnt;
	static int maxPointer;
	static int[] memory;
	static char[] code;
	static char[] input;
	static Bracket[] brackets;
	static StringBuilder sb = new StringBuilder();
	static boolean exit;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for(int testcase=1;testcase<=T;testcase++){
			Stack<Integer> bracketStack = new Stack<Integer>();
			memorySize = sc.nextInt();
			codeSize = sc.nextInt();
			inputSize = sc.nextInt();
			memory = new int[memorySize];
			code = new char[codeSize];
			input = new char[inputSize];
			memoryPointer = inputPointer = codePointer = 0;
			exit = false;
			cnt=0;
			maxPointer=0;
			sc.nextLine();
			String readLine  = sc.nextLine();
			code = readLine.toCharArray();
			brackets = new Bracket[code.length];
			for(int i=0;i<code.length;i++){
				brackets[i] = new Bracket(0,0);
				if(code[i]=='['){
					bracketStack.add(i);
					brackets[i].left=i;
				}else if(code[i]==']'){
					int left = bracketStack.pop();
					brackets[i].right = i;
					brackets[i].left = left;
					brackets[left].right = i;
				}
			}
			readLine = sc.nextLine();
			input = readLine.toCharArray();
			//입력 끝
			//처리
			interPreter();

			//출력
			if(exit) sb.append("Terminates"+"\n");
			else sb.append("Loops"+" "+brackets[maxPointer].left+" "+brackets[maxPointer].right+"\n");
		}
		System.out.println(sb.toString());
	}
	private static void interPreter(){
		while(true){
			//System.out.println("MemoryPointer"+memoryPointer);
			//System.out.println(codePointer);
			//System.out.println(memory[0]+" "+memory[1]+" "+memory[2]);
			switch (code[codePointer]){
			case '-':		
				memory[memoryPointer]-=1; //포인터가 가리키는 숫자 -1
				memory[memoryPointer]%=256;
				codePointer++;
				break;
			case '+':	
				memory[memoryPointer]+=1; //포인터가 가리키는 숫자 +1
				memory[memoryPointer]%=256;
				codePointer++;
				break;
			case '<': 
				memoryPointer--;
				codePointer++;
				//-1이면 반대편으로 넘어간다.
				if(memoryPointer==-1) memoryPointer=memorySize-1;
				break;
			case '>':	
				memoryPointer++;
				codePointer++;
				//memorySize면 반대편으로 넘어간다.
				if(memoryPointer==memorySize) memoryPointer=0;
				break;
			case '[': 
				if(memory[memoryPointer]==0){//0이면 ]로점프
					codePointer = brackets[codePointer].right;
				}else codePointer++;
				break;
			case ']':		
				if(memory[memoryPointer]!=0){//0이아니면 [로 점프
					codePointer = brackets[codePointer].left;
				}else codePointer++;
				break;
			case '.'://포인터가 가리키는 숫자 출력..?	
				codePointer++;
				break;
			case ',':			
				if(inputPointer==inputSize) {
					memory[memoryPointer]=255;
				}
				else {
					memory[memoryPointer]=input[inputPointer];
					inputPointer++;
				}
				codePointer++;
				break;

			}
			//중첩 대괄호중 가장 바깥 대괄호에 의해 무한루프에 빠졌을 수 있으니 maxPointer 지정
			if(codePointer>maxPointer) maxPointer = codePointer;		
			
			if(codePointer==codeSize) {
				exit=true;
				break;
			}
			cnt++;
			if(cnt>=50000001){
				exit=false;
				break;
			}
		}
	}
}
