package Simulation;

import java.util.PriorityQueue;
import java.util.Scanner;

/*
 * 그림을 배열로 표현하는 부분이 까다롭다..
 * 연습장에 엄청 그려보고 구현 방법 생각해냄
 * 6개의 화살표
 */
class Tile implements Comparable<Tile>{
	int id;
	int count;
	public Tile(int i, int c) {
		id = i;
		count = c;
	}
	@Override
	public int compareTo(Tile o) {
		if(this.count==o.count) return Integer.compare(this.count,o.count);
		return Integer.compare(this.id,o.id);
	}
	
}
public class 카탄의개척자 {
	static int[] dr = {0,-1,0,1,-1,1};
	static int[] dc = {1,0,-1,0,1,-1};//우상하좌,우상대각,좌하대각
	static int[][] catanMap;
	static int[][] tileNumber;
	static int centerRow,centerCol;
	static PriorityQueue<Tile> pq;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		catanMap = new int[1000][1000];
		tileNumber = new int[10001][2];
		pq = new PriorityQueue<Tile>();
		centerRow = 499;
		centerCol = 499;
		makePQ();
		makeCatanMap();
		int T = sc.nextInt();
		for(int testcase=1;testcase<=T;testcase++){
			
		}
		
	}
	private static void makePQ() {
		for(int i=1;i<=5;i++) {
			if(i==1) pq.add(new Tile(i,1));
			else pq.add(new Tile(i,0));
		}
	}
	private static void makeCatanMap() {
		int tile = 0;
		int dir=0;//시작
		int curR = centerRow;
		int curC = centerCol;
		catanMap[curR][curC] = 1;
		while(tile<=10000){
			//다음 좌표 구하기
			int nr = curR + dr[dir];
			int nc = curC + dc[dir];
			if(catanMap[nr][nc]==0){//0이면 갈 수 있음.
				int A,B,C;
			}
		}
	}
}
