package SDS복습_그래프;
/*
 * LCA 안보고 구현하기
 * 2^k에서 k를 결정하는 것은
 * 정점의 최대 개수를 넘어서는 k값
 * 
 * 트리가 주어지고 
 * 어떤 두 정점에 대한 공통 조상 찾기
 * 
 * 안보고 구현하되 최대한 깔끔하게 짜보자.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;


public class LCA_LCA복습 {
	//필요한 데이터
	static ArrayList<Integer>[] adjList;//인접리스트
	static int[][] sparesTable;//조상정보 table
	static int[] depth;//트리에서 각 정점이 가지는 깊이
	static int N;//총 node 수 
	
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static void main(String[] args) throws IOException {
		setData();
		setSparesTableAndDepth();
		makeSparesTable();
		excuteQuery();
	}
	
	
	private static void excuteQuery() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		int M = Integer.parseInt(st.nextToken());
		for(int query=0,a,b;query<M;query++){
			st = new StringTokenizer(br.readLine());
			a = Integer.parseInt(st.nextToken());
			b = Integer.parseInt(st.nextToken());
			int lca = findLCA(a,b);
			System.out.println(lca);
		}
	}

	private static int findLCA(int a, int b) {
		if(depth[a]>depth[b]){//깊이 일관성있게 맞추기
			int tmp = a;
			a = b;
			b = tmp;
		}//항상 b가 더 깊도록.
		
		//깊이 맞추기
		for(int k=17;k>=0;k--){//깊이 맞추기
			if(depth[a]<=depth[sparesTable[k][b]]){//계속 더 깊다면
				b = sparesTable[k][b];
			}
		}
		
		//같은 깊이에 위치 시킨 후 부모를 조사
		for(int k=17;k>=0;k--) {
			if(sparesTable[k][a]!=sparesTable[k][b]){//만약 두 부모가 같지 않으면
				a = sparesTable[k][a];
				b = sparesTable[k][b];
			}
		}
		
		int lca = a;
		if(a!=b) lca = sparesTable[0][a];
		return lca;
	}


	//BFS 탐색으로  바로 위 sparesTable 첫번째 줄, 각 노드의 바로 윗 부모 정보 세팅하기
	private static void setSparesTableAndDepth() {
		Queue<Integer> q = new LinkedList<Integer>();
		q.add(1);//루트 삽입
		while(!q.isEmpty()){
			int size = q.size();
			for(int i=0;i<size;i++){
				int parent = q.poll();
				for(int childIdx=0;childIdx<adjList[parent].size();childIdx++){
					int child = adjList[parent].get(childIdx);
					if(sparesTable[0][child]==0) {
						depth[child]=depth[parent]+1;
						sparesTable[0][child] = parent;						
					}
				}
			}
		}
	}

	//점화식으로 sparesTable 완성시키기
	private static void makeSparesTable() {
		for(int k=1;k<=17;k++) {
			for(int node=1;node<=N;node++){
				sparesTable[k][node] = sparesTable[k-1][sparesTable[k-1][node]];
			}
		}
	}


	//Input && Data Setting
	private static void setData() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		adjList = new ArrayList[N+1];
		depth = new int[N+1];
		sparesTable = new int[18][N+1];//조상,정점
		for(int node=1;node<=N;node++) adjList[node] = new ArrayList<Integer>();	
		for(int i=0,from,to;i<(N-1);i++){
			st = new StringTokenizer(br.readLine());
			from = Integer.parseInt(st.nextToken());
			to = Integer.parseInt(st.nextToken());
			adjList[from].add(to);
			adjList[to].add(from);
		}
		depth[1]=0;
		sparesTable[0][1] = 0;
	}
}
