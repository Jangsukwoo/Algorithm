package CodingAcademy;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

/*
 * 문제
 * 숫자가 섞인 보드판을 받은 후
 * 재배열을 통해 원하는 보드판을 만들기
 * 
 * Goal
 * 123
 * 456
 * 78#
 * 
 * 원하는 보드판을 만들 수 없다면 Impossible 출력
 * 
 * bfs와 dfs처럼 a*도 탐색 알고리즘임
 * 
 * f = g+h
 * g = 현재 depth
 * h = heuristic value (Manhattan distance 또는 같지 않은 칸의 개수 등)

1

#13
847
562
 */
public class EightPuzzle_Astar_Algorithm {
	static int T;
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	static StringTokenizer st;
	static char[][] board;
	static char[][] goal;
	static ArrayList<int[]> goalNumberPositionlist = new ArrayList<>();
	static int[] dr = {-1,0,1,0};
	static int[] dc = {0,1,0,-1};
	static HashMap<String,Integer> visitMap;
	static PriorityQueue<Node> pq;
	static class Node{
		String board;
		int g;
		int f;
		public Node(String data,int g,int f) {
			this.board = data;
			this.g=g;
			this.f=f;
		}
	}
	public static void main(String[] args) throws NumberFormatException, IOException {
		T = Integer.parseInt(br.readLine());
		
		setGoalBoard();
		
		for(int testcase=1;testcase<=T;testcase++) {
			br.readLine();//빈라인 read처리
			setData(); //Input
			astarAlgorithm();
			if(visitMap.containsKey("12345678#")){
				bw.write((int) visitMap.get("12345678#")+"\n");
			}else bw.write("impossible"+"\n");
		}
		bw.flush();
		bw.close();
	}
	private static void astarAlgorithm(){
		while(!pq.isEmpty()) {
			Node currentNode = pq.poll();
			String numberBoard = currentNode.board;
			int sharpIndex = numberBoard.indexOf("#");
			int cr = sharpIndex/3;
			int cc = sharpIndex%3;
			String data = "";
			for(int dir=0;dir<4;dir++){//move UP,RIGHT,LEFT,DOWN
				int nr = cr+dr[dir];
				int nc = cc+dc[dir];
				if(rangeCheck(nr,nc)){//영역을 만족 하는 경우
					StringBuilder next = new StringBuilder(numberBoard);
					next = swap(cr,cc,nr,nc,next); //swap
					data = getMapstr(newMap);
					//heuristic logic
					int heuristic = getHeuristicValue(newMap);
					if(visitMap.containsKey(data)) continue;
					else {
						//f =  g+h
						pq.add(new Node(data,currentNode.g+1,(currentNode.g+heuristic)));
						visitMap.put(data,currentNode.g+1);
					}
				}
			}
			//조사 후 
			if(visitMap.containsKey("12345678#")) {
				return; //찾았으면 끝냄 
			}
		}
	}
	private static void view(char[][] map) {
		for(int row=0;row<3;row++) {
			for(int col=0;col<3;col++) {
				System.out.print(map[row][col]);
			}
			System.out.println();
		}
		System.out.println();
		
	}
	private static int getHeuristicValue(char[][] newMap){
		int manhattanDist = 0;
//		for(int num=1;num<9;num++) {
//			boolean find = false;
//			for(int row=0;row<3;row++) {
//				for(int col=0;col<3;col++) {
//					if(newMap[row][col]==(char)(num+'0')) {
//						int[] curG = goalNumberPositionlist.get(num);
//						int gr = curG[0];
//						int gc = curG[1];
//						manhattanDist+= (Math.abs(gr-row) + Math.abs(gc-col));
//						find = true;
//						break;
//					}
//				}
//				if(find) break;
//			}
//		}
		int count = 0 ;
		for(int row=0;row<3;row++) {
			for(int col=0;col<3;col++) {
				if(newMap[row][col]==goal[row][col]) count++;
			}
		}
		return count;
	}
	private static String getMapstr(char[][] newMap){
		String str = "";
		for(int row=0;row<3;row++) {
			for(int col=0;col<3;col++) {
				str+=newMap[row][col];
			}
		}
		return str;
	}
	private static char[][] swap(int cr, int cc, int nr, int nc, StringBuilder next) {
		int currentRC = cc*3+cr;
		int nextRC = nc*3+nr;
		char temp = next.charAt(currentRC);
		next.setCharAt(currentRC,nextRC);
		next.setCharAt(nextRC,temp);
		return newMap;
	}
	private static boolean rangeCheck(int nr, int nc){
		if(nr>=0 && nr<3 && nc>=0 && nc<3) return true;
		return false;
	}
	private static void setGoalBoard() {
		goal = new char[3][3];
		goalNumberPositionlist.add(new int[] {-1,-1});//인덱스 1부터 시작하기 위해 
		char num = '1';
		for(int row=0;row<3;row++) {
			for(int col=0;col<3;col++){
				if(row==2 && col==2) goal[row][col]='#';
				else {
					goal[row][col] = num;
					goalNumberPositionlist.add(new int[] {row,col});
				}
				num++;
			}
		}
	}
	private static void setData() throws IOException {
		board = new char[3][3];
		visitMap = new HashMap<>();
		int sharpRow=0;
		int sharpCol=0;
		String boardStr="";
		for(int row=0;row<3;row++) {
			board[row] = br.readLine().toCharArray();
			for(int col=0;col<3;col++) {
				boardStr+=board[row][col];
				if(board[row][col]=='#') {
					sharpRow = row;
					sharpCol = col;
				}
			}
		}
		pq = new PriorityQueue<>(new Comparator<Node>() {
			@Override
			public int compare(Node o1, Node o2) {
				return Integer.compare(o1.f,o2.f); //f = g+h에서 f기준으로 정렬 
			}
		});
		pq.add(new Node(sharpRow,sharpCol,boardStr,board,0,0));
		visitMap.put(boardStr,0);
	}
}
