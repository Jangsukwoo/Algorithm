package CodingTest;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

public class KAKAOSolution4 {
	static int V,E;
	static int startVertax;
	static ArrayList<int[]>[] adjList;//인접리스트
	static int[][] adjMatrix;
	static PriorityQueue<int[]> pq;
	static int[] dist;
	static int[] from;
	static boolean[] visit;
	static int INF = 987654321;
	
	
	public static void main(String[] args) {
		solution(6,4,6,2, new int[][] {{4, 1, 10}, {3, 5, 24}, {5, 6, 2}, {3, 1, 41}, {5, 1, 24}, {4, 6, 50}, {2, 4, 66}, {2, 3, 22}, {1, 6, 25}});
	}
	public static int solution(int n, int s, int a, int b, int[][] fares){
		int answer = 0;
		initailization(n, fares);
		
		floydwarshall(n);
		
		dijkstra(s,a,n);
		System.out.println(dist[a]);
		return answer;
	}
	private static void floydwarshall(int n) {
		for(int k=0;k<n;k++)
			for(int row=0;row<n;row++)
				for(int col=0;col<n;col++) 
					graph[row][col] = Math.min(graph[row][col],graph[row][k]+graph[k][col]);}
		}
	}
	private static void dijkstra(int startNode, int end, int n) {
		dist[startNode] = 0;
		pq.add(new int[] {startNode,0});
		System.out.println(startNode);
		while(!pq.isEmpty()){//한 정점씩 알아가면서 제일 가까운 거리로만감 -> logV
			int[] currentVertaxInfo = pq.poll();
			int currentVertaxNumber = currentVertaxInfo[0];
			if(visit[currentVertaxNumber]==false){
				visit[currentVertaxNumber] = true; //이제 이 정점에 대한 최단거리는 안다.
				for(int[] nextVertaxInfo : adjList[currentVertaxNumber]){//매달려있는 정점들에 대해 - E
					dist[nextVertaxInfo[0]] = Math.min(dist[nextVertaxInfo[0]],dist[currentVertaxNumber]+nextVertaxInfo[1]);
					//알고있는 거리보다 지금 거리에서 가는게 더 짧을 때 
					pq.add(new int[] {nextVertaxInfo[0],dist[nextVertaxInfo[0]]});//지금까지 온 거리?
				}
			}
		} // O(ElogV)
		System.out.println(Arrays.toString(dist));
		System.out.println(Arrays.toString(from));
	}
	private static void initailization(int n,int[][] fares) {
		dist = new int[n+1];
		from = new int[n+1];
		visit = new boolean[n+1];
		adjList = new ArrayList[n+1];
		adjMatrix = new int[n+1][n+1];
		pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
			@Override
			public int compare(int[] o1, int[] o2) {
				// TODO Auto-generated method stub
				return Integer.compare(o1[1],o2[1]);
			}
		});
		for(int i=1;i<=n;i++) {
			adjList[i] = new ArrayList<int[]>();
			dist[i] = INF; //초기화
			from[i] = -1;
		}
		for(int i=0,from,to,cost;i<fares.length;i++) {
			from = fares[i][0];
			to = fares[i][1];
			cost = fares[i][2];
			adjMatrix[from][to]=cost;
			adjList[to].add(new int[] {from,cost});
			adjList[from].add(new int[] {to,cost});
		}
	}
}
