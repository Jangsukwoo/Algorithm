package winterSDS;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Scanner;

/*
 * 완성된 스도쿠에서 
 * K개의 숫자가 틀린 스도쿠가 주어진다.
 * 1<=K<=3
 * 
 * 바꾸려는 좌표와 바꾸려는 값을 공백을 두어 출력
 * 
 * 
1
2
3 2 4 8 9 1 5 6 7 
8 1 9 7 6 5 2 4 3 
7 5 6 3 4 2 1 9 8 
6 7 1 4 5 3 8 2 9 
4 3 5 9 2 8 7 1 6 
9 8 2 6 1 7 3 5 4 
2 9 3 1 8 6 4 7 5 
1 6 8 5 7 4 9 3 2 
5 4 7 2 3 9 6 8 1 

1
3
8 8 4 8 9 1 5 6 7 
8 8 9 7 6 5 2 4 3 
7 5 6 3 4 2 1 9 8 
6 7 1 4 5 3 8 2 9 
4 3 5 9 2 8 7 1 6 
9 8 2 6 1 7 3 5 4 
2 9 3 1 8 6 4 7 5 
1 6 8 5 7 4 9 3 2 
5 4 7 2 3 9 6 8 1 
3
3 2 4 8 9 1 5 6 7
8 1 9 7 6 5 2 4 3
7 5 6 3 4 2 1 9 8
6 7 1 4 5 3 8 2 9
4 3 5 9 2 8 5 1 6
9 8 2 6 4 7 3 5 4
2 9 3 1 9 6 4 7 5
1 6 8 5 7 4 9 3 2
5 4 7 2 3 9 6 8 1
*/
class Zone{
	HashSet<Integer> row = new LinkedHashSet<Integer>();
	HashSet<Integer> col = new LinkedHashSet<Integer>();
	int leftTopRow;
	int leftTopCol;
	public Zone(int row,int col){
		leftTopRow = row;
		leftTopCol = col;
	}
}
public class searchKforSudoku {
	static int[][] sudokuMap;
	static int[] countMap;//숫자 출현 빈도 저장하기
	static int[] dr = {0,0,0,1,1,1,2,2,2};
	static int[] dc = {0,1,2,0,1,2,0,1,2};
	static boolean[] visit;
	static boolean[] positionVist;
	static int[] tryCase;
	static int[] tryPositionCase;
	static int K;//(1<=K<=3)
	static int wrongPositionSize;
	static ArrayList<Integer> insertNumberList;
	static HashSet<Integer> duplicationSet;
	static ArrayList<int[]> wrongPositionList;
	static Zone[] boxZones;
	static int zoneNumber;
	static boolean find;
	static String answer;
	static String result;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		setBoxZone();
		int T = sc.nextInt();
		for(int testcase=1;testcase<=T;testcase++) {
			K = sc.nextInt();
			sudokuMap = new int[9][9];
			countMap = new int[10];
			insertNumberList = new ArrayList<Integer>();
			wrongPositionList = new ArrayList<int[]>();
			duplicationSet = new LinkedHashSet<Integer>();
			tryCase = new int[K];
			tryPositionCase = new int[K];
			visit = new boolean[K];
			result = "";
			result ="#"+testcase+" ";
			find = false;//초기화처리 끝
			for(int row=0;row<9;row++) {
				for(int col=0;col<9;col++) {
					sudokuMap[row][col] = sc.nextInt();
				}
			}//입력

			//처리
			findWrongPosition();//wrongPositionlist 구하기 (잘못된 자리가 어디인지 좌표를 담는 리스트)
			permutation(0);//kPk
			view();
			System.out.println(result);//출력
		}
	}
	private static void view() {
		for(int row=0;row<9;row++) {
			for(int col=0;col<9;col++) {
				System.out.print(sudokuMap[row][col]+" ");
			}
			System.out.println();
		}
		System.out.println();
	}
	private static void permutation(int cur) {
		if(find==true) return;//찾았으면 더이상 보지않는다.
		if(cur==K){//다 넣었으면 
			answer="";//초기화
			System.out.println("넘버리스트");
			System.out.println(insertNumberList.toString());
			System.out.println("트라이케이스");
			System.out.println(Arrays.toString(tryCase));
			System.out.println("중복케이스");
			System.out.println(duplicationSet.toString());
			positionVist = new boolean[wrongPositionList.size()];
			combination(0,0);//자리뽑기
			
			for(int i=0;i<wrongPositionList.size();i++){
				System.out.println("i값"+i);
				int[] position = wrongPositionList.get(i);
				sudokuMap[position[0]][position[1]]=insertNumberList.get(tryCase[i]);
				answer+=(position[0]+1)+" "+(position[1]+1)+" "+insertNumberList.get(tryCase[i])+" ";
			}
			if(testSudokuMap()){//스도쿠로서 정당한지?
				find = true;
				result+=answer;
			}
			else find = false;
			return;	
		}
		for(int i=0;i<K;i++) {
			if(visit[i]==false) {
				visit[i] = true;
				tryCase[cur] = i;
				permutation(cur+1);
				visit[i] = false;
			}
		}
	}
	private static void combination(int cur) {
		if(cur==K){
			return;
		}
		for(int i=0;i<wrongPositionSize;i++) {
			tryPositionCase[cur] = i;
			dfs(cur+1);
		}
	}
	private static boolean testSudokuMap() {
		for(int i=0;i<wrongPositionList.size();i++) {
			int[] position = wrongPositionList.get(i);
			if(!rowCheck(position[1]) && !colCheck(position[0]) && !boxCheck(position[0],position[1])){
				//셋다 만족하면
				find = true;
			}else return false;
		}
		return true;
	}
	private static void findWrongPosition() {
		setCountMap();//중복된 수와 넣어야할 수 찾기
		for(int row=0;row<9;row++) {
			for(int col=0;col<9;col++) {
				if(rowCheck(col) && colCheck(row) && boxCheck(row,col) && duplicationSet.contains(sudokuMap[row][col])){
					//행,열,영역이 정당한 자리가 아니고 중복된 숫자가 맞는지에 대한 체크
					wrongPositionList.add(new int[] {row,col,zoneNumber});
					System.out.println("행:"+row);
					System.out.println("열:"+col);
					System.out.println();
				}
			}
		}
		wrongPositionSize = wrongPositionList.size();
		System.out.println("잘못된포지션개수");
		System.out.println(wrongPositionSize);
	}
	private static boolean rowCheck(int col) {
		boolean[] check = new boolean[10];
		for(int row=0;row<9;row++) {
			if(check[sudokuMap[row][col]]==false) check[sudokuMap[row][col]]=true;
			else if((check[sudokuMap[row][col]]==true)) return true; //중복 발견
		}
		return false;
	}
	private static boolean colCheck(int row){
		boolean[] check = new boolean[10];
		for(int col=0;col<9;col++) {
			if(check[sudokuMap[row][col]]==false) check[sudokuMap[row][col]]=true;
			else if((check[sudokuMap[row][col]]==true)) return true; //중복 발견
		}
		return false;
	}
	private static boolean boxCheck(int row, int col) {
		int boxZone = 0;
		boolean[] check = new boolean[10];	
		for(int i=0;i<9;i++) {
			if(boxZones[i].row.contains(row) && boxZones[i].col.contains(col)){//속한 영역 확인
				boxZone = i;
				break;
			}
		}
		zoneNumber = boxZone;
		for(int dir=0;dir<9;dir++) {
			if(check[sudokuMap[boxZones[boxZone].leftTopRow+dr[dir]][boxZones[boxZone].leftTopCol+dc[dir]]]==false) {
				check[sudokuMap[boxZones[boxZone].leftTopRow+dr[dir]][boxZones[boxZone].leftTopCol+dc[dir]]]=true;	
			}else return true;
		}
		return false;
	}
	private static void setCountMap() {
		for(int row=0;row<9;row++) {
			for(int col=0;col<9;col++) {
				countMap[sudokuMap[row][col]]+=1;
			}
		}
		System.out.println("카운트맵");
		System.out.println(Arrays.toString(countMap));
		for(int num=1;num<=9;num++) {
			if(countMap[num]<9){
				for(int i=0;i<(9-countMap[num]);i++) insertNumberList.add(num);
			}
			if(countMap[num]>9) {
				for(int i=0;i<(countMap[num]-9);i++) duplicationSet.add(num);
				
			}
		}
	}
	private static void setBoxZone() {
		boxZones = new Zone[9];
		boxZones[0] = new Zone(0,0);
		boxZones[1] = new Zone(0,3);
		boxZones[2] = new Zone(0,6);
		boxZones[3] = new Zone(3,0);
		boxZones[4] = new Zone(3,3);
		boxZones[5] = new Zone(3,6);
		boxZones[6] = new Zone(6,0);
		boxZones[7] = new Zone(6,3);
		boxZones[8] = new Zone(6,6);
		for(int i=0;i<9;i++) { //각 박스별로 
			for(int dir=0;dir<9;dir++) {
				boxZones[i].row.add(boxZones[i].leftTopRow+dr[dir]);
				boxZones[i].col.add(boxZones[i].leftTopCol+dc[dir]);
			}
		}
	}
}
