package CodingStudySamsungProblem;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

/*
 * 다리만들기 2 크루스칼로 풀어보기
 */
public class 다리만들기2 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	static StringTokenizer st;
	static int N,M;
	static int[][] islandMap;
	static int[][] map;
	static int[] parent;
	static ArrayList<Edge> edges;
	static int[] dr = {-1,0,1,0};
	static int[] dc = {0,1,0,-1};
	static class Edge{
		int from;
		int to;
		int cost;
		public Edge(int f,int t, int c) {
			from = f;
			to = t;
			cost = c;
		}
	}
	public static void main(String[] args) throws IOException {
		setData();
		setIslandMap();
		getEdges();
		kruscal();
	}
	private static void kruscal() {
		Collections.sort(edges);
	}
	private static void getEdges(){
		for(int row=0;row<N;row++) {
			for(int col=0;col<M;col++){
				if(islandMap[row][col]!=0){//섬이면
					int fromNumber = islandMap[row][col];
					for(int dir=0;dir<4;dir++){
						int nr = row+dr[dir];
						int nc = col+dc[dir];
						int dist=1;
						while(true){
							if(rangeCheck(nr, nc)){
								if(islandMap[nr][nc]!=fromNumber && islandMap[nr][nc]!=0){//자기 자신도 아니고 다른 섬이면
									edges.add(new Edge(fromNumber,islandMap[nr][nc],dist));
									break;
								}else if(islandMap[nr][nc]==fromNumber) break;
							}else break;
							nr+=dr[dir];
							nc+=dc[dir];
							dist++;
						}
					}
				}
			}
		}
	}
	private static void view() {
		for(int row=0;row<N;row++) {
			for(int col=0;col<M;col++) {
				System.out.print(islandMap[row][col]);
			}
			System.out.println();
		}
	}
	private static void setIslandMap(){
		int islandNumber=1;
		boolean[][] visit = new boolean[N][M];
		for(int row=0;row<N;row++){
			for(int col=0;col<M;col++){
				if(map[row][col]==1 && visit[row][col]==false){
					Queue<int[]> q = new LinkedList<int[]>();
					q.add(new int[] {row,col});
					visit[row][col] = true;
					islandMap[row][col] = islandNumber;
					while(!q.isEmpty()){
						int[] current = q.poll();
						for(int dir=0;dir<4;dir++) {
							int nr = current[0]+dr[dir];
							int nc = current[1]+dc[dir];
							if(rangeCheck(nr,nc)) {
								if(map[nr][nc]==1 && visit[nr][nc]==false){
									islandMap[nr][nc] = islandNumber;
									visit[nr][nc] = true;
									q.add(new int[] {nr,nc});
								}
							}
						}
					}
					islandNumber++;
				}
			}
		}
	}
	private static boolean rangeCheck(int nr, int nc) {
		if(nr>=0 && nr<N && nc>=0 && nc<M) return true;
		return false;
	}
	private static void setData() throws IOException {
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		map = new int[N][M];
		islandMap = new int[N][M];
		edges = new ArrayList<Edge>();
		for(int row=0;row<N;row++) {
			st = new StringTokenizer(br.readLine());
			for(int col=0;col<M;col++){
				map[row][col] = Integer.parseInt(st.nextToken());
			}
		}
	}
}
