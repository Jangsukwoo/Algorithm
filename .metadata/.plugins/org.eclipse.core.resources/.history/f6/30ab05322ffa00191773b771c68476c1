package Simulation;

import java.util.Scanner;

/*
 * 4:50~5:30
 * 6:00~
 * 
 * 정수를 담는 1개의 배열
 * 이 배열의 칸 하나를 가리키는 포인터
 * 명령구성
 * - : 포인터가 가리키는 숫자 1 감소
 * + : 포인터가 가리키는 숫자 1 증가
 * < : 포인터 왼쪽 이동
 * > : 포인터 오른쪽 이동
 * [ : 포인터가 가리키는 숫자가 0이면 [와 짝을 이루는 ]로 점프
 * ] : 포인터가 가리키는 숫자가 0이 아니면 ]와 짝을 이루는 [로 점프
 * . : 포인터가 기리키는 숫자 출력
 * , : 문자 하나를 읽고 포인터가 가리키는 곳에 저장. 입력의 마지막(EOF)인 경우 255 저장
 * 
 * 첫번째 명령부터 순차적으로 수행하고
 * 수행할 명령이 없으면 프로그램이 종료된다.
 * 데이터 배열의 값은 0으로 초기화되어있고 포인터가 가리키는 칸은 0이다.
 * 
 * [의 개수 - ]의 개수가 0이거나 큰 값으로 종료되면 잘 짜여진 프로그램이다.
 * 이 문제는 이 프로그램이 무한루프에 빠지는지 안빠지는지 판단하는 코드를 짜면된다.
 */
public class BrainFuckInterpreter {
	static int memorySize;
	static int codeSize;
	static int inputSize;
	static int memoryPointer,inputPointer,codePointer;
	static int infiniteLeftSide,infiniteRightSide;
	static int[] memory;
	static char[] code;
	static char[] input;
	static boolean exit;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for(int testcase=1;testcase<=T;testcase++) {
			memorySize = sc.nextInt();
			codeSize = sc.nextInt();
			inputSize = sc.nextInt();
			memory = new int[memorySize];
			code = new char[codeSize];
			input = new char[inputSize];
			memoryPointer = inputPointer = infiniteLeftSide = infiniteRightSide = 0;
			exit = false;
			sc.nextLine();
			String readLine  = sc.nextLine();
			code = readLine.toCharArray();
			readLine = sc.nextLine();
			input = readLine.toCharArray();
			//입력 끝

			//처리
			interPreter();

			//출력
			if(exit)System.out.println("Terminates");
			else System.out.println("Loops"+" "+infiniteLeftSide+" "+infiniteRightSide);
		}
	}
	private static void interPreter() {
		while(true){
			System.out.println("코드포인터"+codePointer);
			System.out.println("메모리값"+memory[memoryPointer]);
			switch (code[codePointer]){
			case '-':		
				memory[memoryPointer]-=1; //포인터가 가리키는 숫자 -1
				codePointer++;
				break;
			case '+':	
				memory[memoryPointer]-=1; //포인터가 가리키는 숫자 +1
				codePointer++;
				break;
			case '<': 
				memoryPointer-=1;
				if(memoryPointer==-1) memoryPointer=memorySize-1;
				codePointer++;
				//-1이면 반대편으로 넘어간다.
				break;
			case '>':	
				memoryPointer+=1;
				if(memoryPointer==memorySize) memoryPointer=0;
				codePointer++;
				break;
			case '[': 
				if(memory[memoryPointer]==0){//0이면 ]로점프
					infiniteLeftSide = codePointer;
					for(int i=codePointer;i<codeSize;i++){
						if(code[i]==']') {
							codePointer = i;
							infiniteRightSide = codePointer;
							break;
						}
					}
				}else codePointer++;
				break;
			case ']':		
				if(memory[memoryPointer]!=0){//0이아니면 [로 점프
					infiniteRightSide = codePointer;
					for(int i=codePointer;i>=0;i--){
						if(code[i]=='[') {
							codePointer = i;
							infiniteLeftSide = codePointer;
							break;
						}
					}					
				}else codePointer++;
				break;
			case '.'://포인터가 가리키는 숫자 출력..?	
				codePointer++;
				break;
			case ',':			
				if(inputPointer==inputSize) memory[memoryPointer]=255;
				else {
					memory[memoryPointer]=input[inputPointer];
					inputPointer++;
				}
				codePointer++;
				break;

			}
			if(codePointer==codeSize) {
				exit=true;
				break;
			}
		}
	}
}
