package CodingStudyHW;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 * 20:13~
 * 차근차근 ㅎㅎ
 * 예쁘게 짜보자
 * 
 * 크기 3 by 3
 * 1. 행의 개수가 열의 개수보다 같거나 클때
 * R연산 : 모든 행에 대해 정렬
 * 2. 행의 개수가 열의 개수보다 작을 때 
 * C연산 : 모든 열에 대해 정렬
 * 
 * 수의 등장 회수가 커지는 순서로. 그러한 수자 여러가지면 수가 커지는 순으로 정렬.
 * 
 * 이 연산을 통하면
 * 행과 열의 크기가 변하게 되는데
 * 이때 가장 큰 행, 가장 큰 열 기준으로 배열의 크기를 재할당
 * 수를 정렬할 때 0은 무시한다.
 * 또한, 행과 열의 크기가 100을 넘어가는 경우
 * 처음 100개 제외한 나머지 버림
 * A[r][c] 값이 k가 되기 위한 최소 시간은?
 * 단, 값이 100을 넘어가는 경우 -1 출력하고 끝
 * 
 */
public class 이차원배열과연산 {
	static int r,c,k;
	static int Rsize,Csize;
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	static int[][] array;
	static boolean find;
	public static void main(String[] args) throws IOException {
		setData();
		calculation();
	}
	private static void calculation() {
		int time=0;
		while(true){
			if(r<)
		}
	}
	private static void setData() throws IOException {
		st = new StringTokenizer(br.readLine());
		r = Integer.parseInt(st.nextToken())-1;
		c = Integer.parseInt(st.nextToken())-1;
		k = Integer.parseInt(st.nextToken());
		Rsize = 3;
		Csize = 3;
		for(int row=0;row<3;row++) {
			st = new StringTokenizer(br.readLine());
			for(int col=0;col<3;col++) {
				array[row][col] = Integer.parseInt(st.nextToken());
			}
		}
	}
}
