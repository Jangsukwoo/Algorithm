package SDS복습_그래프;
/*
 * LCA 안보고 구현하기
 * 2^k에서 k를 결정하는 것은
 * 정점의 최대 개수를 넘어서는 k값
 * 
 * 트리가 주어지고 
 * 어떤 두 정점에 대한 공통 조상 찾기
 * 
 * 안보고 구현하되 최대한 깔끔하게 짜보자.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;


public class LCA_LCA복습 {
	//필요한 데이터
	static ArrayList<Integer>[] adjList;//인접리스트
	static int[][] sparesTable;//조상정보 table
	static int[] depth;//트리에서 각 정점이 가지는 깊이
	static int N;//총 node 수 
	public static void main(String[] args) throws IOException {
		setData();
		setSparesTable();
	}
	
	
	
	private static void setSparesTable() {
		Queue<Integer> q = new LinkedList<Integer>();
		boolean[] visit = new boolean[N+1];
		q.add(1);//루트 삽입
		visit[1] = true;
		while(!q.isEmpty()){
			int size = q.size();
			for(int i=0;i<size;i++){
				int parent = q.poll();
				
			}
		}
	}



	//Input && Data Setting
	private static void setData() throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		adjList = new ArrayList[N+1];
		depth = new int[N+1];
		sparesTable = new int[17][N+1];//조상,정점
		for(int node=1;node<=N;node++) adjList[node] = new ArrayList<Integer>();	
		for(int i=0,from,to;i<(N-1);i++){
			st = new StringTokenizer(br.readLine());
			from = Integer.parseInt(st.nextToken());
			to = Integer.parseInt(st.nextToken());
			adjList[from].add(to);
			adjList[to].add(from);
		}
		depth[1]=0;
		sparesTable[0][1] = 0;
	}
}
