package SDS복습;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

import com.sun.org.apache.bcel.internal.generic.SWAP;

import jdk.javadoc.internal.doclets.formats.html.markup.Head;

/*
 * 최소힙
 * 배열로 트리를 구현해보자
 * 
 */
public class 자료구조_최소힙 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	static int[] tree;//maxHeap
	static int nodeSize;
	static int N;
	public static void main(String[] args) throws NumberFormatException, IOException {
		N = Integer.parseInt(br.readLine());
		tree = new int[N+1];//배열 트리
		for(int i=0,value;i<N;i++){
			value = Integer.parseInt(br.readLine());
			switch (value) {
			case 0:
				delete();
				break;
			default:
				insert(value);
				break;
			}
		}
	}
	private static void delete() {
		if(nodeSize==0) bw.write("0"+"\n");
		else {
			bw.write(tree[nodeSize]+"\n");//삭제처리
			int childIdx = nodeSize;
			int parentIdx = nodeSize/2;
			while(true){
				if(tree[parentIdx]>tree[childIdx]){
					swap(parentIdx,childIdx);
				}else break;//아니면 나와버림
			}
			nodeSize--;
		}
		
	}
	private static void insert(int value) {
		if(nodeSize==0){//현재 노드사이즈가 0이면
			nodeSize++;
			tree[nodeSize] =value;
		}else {
			nodeSize++;
			tree[nodeSize] = value;
			int childIdx = nodeSize;
			int parentIdx = nodeSize/2;
			while(true){
				if(tree[parentIdx]>tree[childIdx]){
					swap(parentIdx,childIdx);
				}else break;//아니면 나와버림
			}
		}
	}
	private static void swap(int parentIdx, int childIdx) {
		int tmp = tree[parentIdx];
		tree[parentIdx] = tree[childIdx];
		tree[childIdx] = tmp;
	}
}
