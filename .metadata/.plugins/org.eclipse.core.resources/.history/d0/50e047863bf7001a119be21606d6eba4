package SamsungDS;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class 오래된스마트폰 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	static int N,O,M,W;
	static int[] possibleNumber;
	static int[] possibleOperator;
	static boolean[] visit;
	static Queue<PushValue> q = new LinkedList<String>();
	static class PushValue{
		String number_string;
		int push;
		public PushValue(String number_string, int push) {
			this.number_string = number_string;
			this.push = push;
		}
	}
	static int answer;
	/*
	 * 최소 터치 회수 
	 * 1 = +
	 * 2 + -
	 * 3 = *
	 * 4 = /
	 */
	public static void main(String[] args) throws NumberFormatException, IOException{
		int T = Integer.parseInt(br.readLine());
		for(int testcase=1;testcase<=T;testcase++) {
			setData();
			
			initialization();
			answer = bfs();
		}
	}
	private static int bfs() {
		int manipulation = 1;
		while(!q.isEmpty()){ //각 레벨에서 가능한 모든 경우를 넣는다.
			int size = q.size();
			for(int i=0;i<size;i++){
				
				PushValue currentPushValue = q.poll();
				
				String currentNumber_string =currentPushValue.number_string;
				
				int currentNumber = Integer.parseInt(currentNumber_string);
				
				if(currentNumber==W) return manipulation; //발견 즉시 리턴
				
				if(currentNumber_string.charAt(0)=='0') continue; //앞자리 0은 건너뜀
			
				pasteCase(currentNumber_string);//뒤에 숫자 붙여보는 경우
				
				operationCase(currentNumber_string); //연산해서 넣어보는 경우
			}
			
			manipulation++;
		}
		return -1;
	}
	
	private static void pasteCase(String currentNumber_string) {
		for(int i=0;i<N;i++) {
			String pasteNumber = currentNumber_string+Integer.toString(possibleNumber[i]);
			insertQueue(pasteNumber);
		}
	}
	private static void operationCase(String currentNumber_string) {
		
	}
	private static void insertQueue(String number_string) {
		///한번더 확인하지 못한 숫자인지 유효성을 검증하고 큐에 담는다.
		int number = Integer.parseInt(number_string);
		if(visit[number]==false) {
			q.add(Integer.toString(number));
			visit[number] = true;
		}
	}
	private static void setData() throws IOException {
		q.clear();
		visit = new boolean[1000]; //999x 9 => 넉넉히 9000
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		O = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		possibleNumber = new int[N];
		possibleOperator = new int[O];
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<N;i++) possibleNumber[i] = Integer.parseInt(st.nextToken());
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<O;i++) possibleOperator[i] = Integer.parseInt(st.nextToken());
		W = Integer.parseInt(br.readLine());
	}
	private static void initialization() {
		for(int i=0;i<N;i++) {
			String rootNumber = Integer.toString(possibleNumber[i]);
			q.add(new PushValue(rootNumber, 1));
		}
	}
}
