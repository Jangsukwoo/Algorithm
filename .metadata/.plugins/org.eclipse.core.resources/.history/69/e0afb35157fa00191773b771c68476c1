package BAEKJOON;
import java.util.LinkedList;
import java.util.Queue;
/*
 * 11:05~
 * 체스판 사이즈 RxC (행x열)
 * 각 칸 위에 공이 하나씩 놓여진다.
 * 각 공은 인접한 8방향에 적힌 모든 정수가 
 * 현재 칸에 적힌 수보다 크면 이동을 멈춘다.
 * 그 외의 경우에는 가장 작은 정수가 있는 칸으로 공이 이동한다.
 * 
 * 한 칸 위에 여러 개의 공이 있을 수 있다.
 * 공이 더 이상 움직이지 않을 때 각 칸에 공이 몇 개 있는지
 * 체스판에 적어서 출력
 */
import java.util.Scanner;

public class 체스판위의공 {
	static int R,C;
	static int[] dr = {-1,-1,0,1,1,1,0,-1};
	static int[] dc = {0,1,1,1,0,-1,-1,-1};
	static int[][] chessBoard;
	static Queue<int[]> q = new LinkedList<int[]>();
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		R = sc.nextInt();
		C = sc.nextInt();
		chessBoard = new int[R][C];
		for(int row=0;row<R;row++) {
			for(int col=0;col<C;col++){
				chessBoard[row][col] = sc.nextInt();
				q.add(new int[] {row,col});
			}
		}
		move();
	}
	private static void move() {
		while(!q.isEmpty()){
			int[] RC = q.poll();//꺼냄
			int min = 300000;
			int[] minRC;
			for(int dir=0;dir<8;dir++){//8방향 탐색
				int nr = RC[0]+dr[dir];
				int nc = RC[1]+dc[dir];
				if(rangeCheck(nr,nc)){//영역 만족하고
					if(chessBoard[nr][nc]<chessBoard[RC[0]][RC[1]]){
						//값이 더 작은 경우
						if(chessBoard[nr][nc]<min){//알고 있는 min값 보다 더 작으면
							minRC = new int[]{nr,nc};
							min = chessBoard[nr][nc];
						}
					}
				}
			}//탐색이 끝난 후
		}
	}
	private static boolean rangeCheck(int nr, int nc) {
		if(nr>=0 && nr<R && nc>=0 && nc<C) return true;
		return false;
	}
}
