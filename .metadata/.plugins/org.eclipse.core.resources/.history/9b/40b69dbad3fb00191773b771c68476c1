package Simulation;

import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Scanner;

/*
 * 그림을 배열로 표현하는 부분이 까다롭다..
 * 연습장에 엄청 그려보고 구현 방법 생각해냄
 * 6개의 화살표
 */
class Tile implements Comparable<Tile>{
	int id;
	int count;
	public Tile(int i, int c) {
		id = i;
		count = c;
	}
	@Override
	public int compareTo(Tile o) {
		if(this.count==o.count) return Integer.compare(this.count,o.count);
		return Integer.compare(this.id,o.id);
	}

}
public class 카탄의개척자 {
	static int[] dr = {0,-1,-1,-1,0,1,1,1};
	static int[] dc = {1,1,0,-1,-1,-1,0,1};//우->우상대각->상->좌상대각->....->우하대각 반시계방향
	//우 : 0, 상 : 2, 좌 : 4, 하 : 6
	static int[][] catanMap;
	static int[][] catanCount;
	static int[][] tileNumber;
	static int centerRow,centerCol;
	static PriorityQueue<Tile> pq;
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		catanMap = new int[100][100];
		tileNumber = new int[10001][2];
		pq = new PriorityQueue<Tile>();
		centerRow = 49;
		centerCol = 49;
		makePQ();
		makeCatanMap();
		view();
		int T = sc.nextInt();
		for(int testcase=1;testcase<=T;testcase++){
			int n = sc.nextInt();
			System.out.println(catanMap[tileNumber[n][0]][tileNumber[n][1]]);
		}
	
	}
	private static void view() {
		for(int row=0;row<100;row++) {
			for(int col=0;col<100;col++) {
				System.out.print(catanCount[row][col]+" ");
			}
			System.out.println();
		}
		System.out.println();
	}
	private static void makePQ() {
		for(int i=1;i<=5;i++) {
			if(i==1) pq.add(new Tile(i,1));
			else pq.add(new Tile(i,0));
		}
	}
	private static void makeCatanMap() {
		int tile = 1;
		int dir=0;//시작
		int curR = centerRow;
		int curC = centerCol;
		int cnt=1;
		catanMap[curR][curC] = 1;
		catanCount[curR][curC]=1;
		while(tile<=10000){
			//다음 좌표 구하기
			tileNumber[tile][0] = curR;
			tileNumber[tile][1] = curC;
			catanCount[curR][curC]=cnt++;
			int nr = curR + dr[dir];
			int nc = curC + dc[dir];//  다음좌표
			int ndir = (dir+2)%8;
			if(catanMap[nr][nc]==0){//0이면 갈 수 있다.	
				//adj 배열에는 다음칸이 인접한 최대 3개의 값 넣기
				int[] adj = new int[3];
				for(int i=0;i<3;i++){
					int nnr = nr+dr[(ndir+i)%8];
					int nnc = nc+dc[(ndir+i)%8];
					adj[i] = catanMap[nnr][nnc];
				}

				//pq에서 꺼내면서 가능한 값 적기
				ArrayList<Tile> tmp = new ArrayList<Tile>();//제외되면 임시로 저장될 리스트
				for(int i=0;i<5;i++){//넣을 값 check. 최대 5개
					Tile curTile = pq.poll();
					boolean possible = true;
					for(int j=0;j<3;j++){
						if(curTile.id==adj[j]){//같으면 안된다.
							tmp.add(curTile);
							possible =false;
							break;
						}
					}
					if(possible){//가능한 숫자면
						catanMap[nr][nc] = curTile.id;
						curTile.count+=1;
						pq.add(curTile);
						for(Tile t : tmp) pq.add(t);
						break;//넣었으니 종료
					}
				}

				//다음 좌표 설정
				dir = ndir;//다음 방향으로 정해버림
				curR = nr;
				curC = nc;
			}
			else{//갈 수 없다면?
				nr = 0;
				nc = 0;
				switch (dir){//가려고 하는 방향이 다음과 같다면 다음 좌표를 정해준다
				case 0://우
					nr = curR+dr[6];
					nc = curC+dc[6];//아래로
					break;
				case 2://상
					nr = curR+dr[1];
					nc = curC+dc[1];
					break;
				case 4:				
					nr = curR+dr[2];
					nc = curC+dc[2];//위로
					break;
				case 6:	
					nr = curR+dr[5];
					nc = curC+dc[5];
					break;
				}
				int[] adj = new int[3];
				for(int i=0;i<3;i++){
					int nnr = nr+dr[(dir+i)%8];
					int nnc = nc+dc[(dir+i)%8];
					adj[i] = catanMap[nnr][nnc];
				}

				//pq에서 꺼내면서 가능한 값 적기
				ArrayList<Tile> tmp = new ArrayList<Tile>();//제외되면 임시로 저장될 리스트
				for(int i=0;i<5;i++){//넣을 값 check. 최대 5개
					Tile curTile = pq.poll();
					boolean possible = true;
					for(int j=0;j<3;j++){
						if(curTile.id==adj[j]){//같으면 안된다.
							tmp.add(curTile);
							possible =false;
							break;
						}
					}
					if(possible){//가능한 숫자면
						catanMap[nr][nc] = curTile.id;
						curTile.count+=1;
						pq.add(curTile);
						for(Tile t : tmp) pq.add(t);
						break;//넣었으니 종료
					}
				}
				//다음 좌표 설정
				dir = ndir;//다음 방향으로정하지않음 
				curR = nr;
				curC = nc;
			}
			tile++;
		}
	}
}

