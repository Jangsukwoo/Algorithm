package SDS;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/*
 * Two Pointer?? 
 * https://www.youtube.com/watch?v=2wVjt3yhGwg&t=6s
 * 
 * 스트링,배열,링크드리스
 * O(n^2) or O(n^3)를 O(n)으로 줄여줄 수 있다.
 * 
 * 정렬상태에 따라 O(nlogn)까지 걸릴 수 있다.
 * 
 * 숫자 배열이 있고
 * 배열을 포인팅하는 두개의 포인터를 만든다. startPointer, endPointer
 * 
 * ---백준 1806번 <- 투포인터 ---
 * 길이 N짜리의 수열 입력
 * 10<=N<=100000
 * 
 * 연속된 수들의 부분합이 1억 이상이 되는 부분 수열중 가장 짧은 것의 길이를 구한다.
 */
public class 시간복잡도_부분합_투포인터 {
	static int N,targetSum,minLength;
	static int startPointer,endPointer;
	static int[] series;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		targetSum = Integer.parseInt(st.nextToken());
		series = new int[N];
		minLength = 100000;//최대 길이
		st = new StringTokenizer(br.readLine());
		for(int i=0;i<N;i++) series[i] = Integer.parseInt(st.nextToken());
		twoPointer();
		System.out.println(minLength);
	}
	private static void twoPointer() {
		long sum=0;
		while(endPointer<N){//endPointer를 끝까지 
			sum+=series[endPointer];
			if(sum>targetSum){
				while(startPointer<endPointer){
					if((sum-series[startPointer])>=targetSum){
						sum-=series[startPointer];
						startPointer++;
					}else break;
				}
				minLength = Math.min(minLength,(endPointer-startPointer+1));
			}else endPointer++;			
//			System.out.println("스타트포인터:"+startPointer);
//			System.out.println("앤드포인터"+endPointer);
//			System.out.println("현재 sum값"+sum);
//			System.out.println();
		}
	}
}
