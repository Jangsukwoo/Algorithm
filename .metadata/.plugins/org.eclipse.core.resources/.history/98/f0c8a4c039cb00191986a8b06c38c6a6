import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
 
//0,1,2,3 - 상하좌우
class Atomic{
    int row;
    int col;
    int dir;
    int energy;
    Atomic(int r, int c, int d, int e){
        row=r;
        col=c;
        dir=d;
        energy=e;
    }
    @Override
    public String toString() {
        return "Atomic [row=" + row + ", col=" + col + ", dir=" + dir + ", energy=" + energy + "]";
    }
     
}
 
 
public class 원자소멸 {
    static int T,N,sumEnergy;
    static Atomic[] atomicQueue = new Atomic[1000];
    static int[][] testMap;
    static int dr[] = {1,-1,0,0};
    static int dc[] = {0,0,-1,1};
	public static int front = 0;
	public static int rear = 0;
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        T = sc.nextInt();
        for(int testcase=1;testcase<=T;testcase++){
            N = sc.nextInt();
            testMap = new int[4002][4002];
 
            for(int i=0;i<N;i++) {
                int x = (sc.nextInt()+1000)*2; //열
                int y = (sc.nextInt()+1000)*2; //행
                int dir = sc.nextInt();
                int K = sc.nextInt();
                 
                atomqueue.add(new Atomic(y,x,dir,K));
            }
//          System.out.println(atomqueue);
///////////////////////////////         
            sumEnergy=0;
             
             
            Move();
             
            /////
            System.out.println("#"+testcase+" "+sumEnergy);
        }
    }
    private static void Move() {
 
        while(!atomqueue.isEmpty()){
             //맵 다시
             
            int atomequeueSize = atomqueue.size();
            if(atomequeueSize==1) break;
            for(int i=0;i<atomequeueSize;i++) {
 
                Atomic currentAtomic1 = atomqueue.poll();       
                int nr = currentAtomic1.row+dr[currentAtomic1.dir];
                int nc = currentAtomic1.col+dc[currentAtomic1.dir];     
                 
//              System.out.println("nr"+nr);
//              System.out.println("nc"+nc);
                 
                if(rangeCheck(nr,nc)) { //이동은 성공
                     
                    //
                    if(testMap[nr][nc]==0) {//이동한 곳이 새 땅이면
                         
                         
                        atomqueue.add(new Atomic(nr,nc,currentAtomic1.dir,currentAtomic1.energy));//그대로 넣음
                        testMap[nr][nc]+=1;
                    }
                     
                    else if(testMap[nr][nc]>=1){//누군가 밟은곳이라면 넣지않고 에너지 넣고 skip
                     
                        sumEnergy += currentAtomic1.energy;
                        testMap[nr][nc]+=1;
                    }
                }
            }//처음이동 
             
            int newatomequeueSize = atomqueue.size();//잔류 원자
             
             
            //생존 check
            for(int i=0;i<newatomequeueSize;i++) {   
                Atomic currentAtomic = atomqueue.poll();    
                if(testMap[currentAtomic.row][currentAtomic.col]==1){//1이면 자기 자신만 밟은거니까     
                     
                    atomqueue.add(new Atomic(currentAtomic.row,currentAtomic.col,currentAtomic.dir,currentAtomic.energy));//그대로
                }
                 
                else if(testMap[currentAtomic.row][currentAtomic.col]>1){//1보다 크면 어떤 원자가 와서 죽은거니까 더함.
 
                    sumEnergy += currentAtomic.energy;
                }
                testMap[currentAtomic.row][currentAtomic.col] = 0;
            }//처음이동 
             
        }   
    }
    private static boolean rangeCheck(int nr, int nc) {
        if((nr>=0 && nr<4002) && (nc>=0 && nc<4002)) return true; //영역 만족
        return false; //범위 밖
    }

	private static boolean isempty() {
		if(rear==front) return true;
		else return false;
	}
	private static int size() {
		return (rear-front);
	}
	private static void pop() {
		if(rear!=front) System.out.println(atomicQueue[front++]);
		else System.out.println("-1");
	}
	private static void push(Atomic value) {
		if(rear<10000) atomicQueue[rear++]=value;
		else System.out.println("-1");
		
	}
}